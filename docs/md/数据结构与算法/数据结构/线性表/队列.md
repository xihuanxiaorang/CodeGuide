---
title: 队列
tags:
  - 数据结构
  - 线性表
  - 队列
created: 2022-11-09 21:07:11
modified: 2022-11-09 21:07:11
number headings: auto, first-level 1, max 6, _.1.1.
---

# 队列

## 1. 定义

**队列（queue）**是一种只能在不同端进行插入或删除操作的线性表，进行插入操作的一端称为**队尾（rear）**，进行删除操作的一端称为**队头（front）**，队列的插入操作通常称为 **入队（push）**，队列的删除操作通常称为 **出队（pop）**。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为 **先进先出（FIFO）线性表**。

## 2. 实现方式

主要有 **顺序队** 和 **链队** 两种实现方式。

队列主要有如下几个方法：

1. `void offer(E element)` 方法，元素入队
2. `E poll()` 方法，元素出队
3. `E element()` 方法，查看队头元素
4. `boolean isEmpty()` 方法，判断队列是否为空

### 2.1. 顺序队

顺序队使用数组来实现。

#### 2.1.1. 顺序队列

建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。约定：一个是 **队头指针 `front`**，它指向队头元素的前一个位置；另一个是 **队尾指针 `rear`**，它指向队尾元素所在位置。

每次在队尾插入一个元素时，`rear` 加一；每次在队头删除一个元素时，`front` 加一。随着插入和删除操作的进行，队列元素的个数不断变化，队列所占的存储空间也在队列结构所分配的连续空间中移动。当 `front = rear` 时，表示队列中没有任何元素，称为 **空队列**。当 `rear` 增加到指向分配的连续空间之外时，队列无法再插入新元素，但这时往往还有大量可用空间未被占用，这些空间是已经出队的队列元素曾经占用过的存储单元。如下图所示：

![image-20221115005357067](https://fastly.jsdelivr.net/gh/xihuanxiaorang/images/202211150053122.png)

顺序队列中的溢出现象：

1. “下溢”现象：当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。
2. “真上溢”现象：当队列满时，做进队运算产生的溢出现象。“真上溢”是一种出错状态，应设法避免。
3. **“假上溢”现象**：由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于分配的队列空间规模时，也可能由于尾指针已超越队列空间的上界而不能做入队操作，该现象称为“假上溢”现象。

##### 2.1.1.1. 入队

```java
public void offer(E element) {
    if (rear == elementData.length - 1) {
        throw new IllegalStateException("Queue full");
    }
    elementData[++rear] = element;
}
```

##### 2.1.1.2. 出队

```java
public E poll() {
    if (isEmpty()) {
        throw new IllegalStateException("Queue empty");
    }
    E element = (E) elementData[++front];
    return element;
}
```

2.1.1.3. 查看队头元素

```java
public E element() {
    if (isEmpty()) {
        throw new IllegalStateException("Queue empty");
    }
    return (E) elementData[front + 1];
}
```

##### 2.1.1.3. 队空

```java
public boolean isEmpty() {
    return front == rear;
}
```

#### 2.1.2. 循环队列

在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：无论插入或删除，一旦 `rear` 指针或 `front` 指针加一时超出了所分配的队列空间，就让它指向这片连续空间的起始位置。这实际上是把队列空间想象成一个环形空间，环形空间中的存储单元循环使用，用这种方法管理的队列也就称为 **循环队列**。

在循环队列中，当队列为空时，有 `front = rear`，而当所有队列空间全占满时，也有 `front = rear`。为了区别这两种情况，规定循环队列最多只能有 `capcity - 1` 个队列元素，当循环队列种只剩下一个空存储单元时，队列就已经满了。因此，**队列判空的条件为 `front = rear`**，而 **队列判满的条件为 `front = (rear + 1) % capcity`**，**队列中的元素个数为 `(rear - front + capcity) % capcity`**。

![image-20221115004729046](https://fastly.jsdelivr.net/gh/xihuanxiaorang/images/202211150047118.png)

##### 2.1.2.1. 入队

```java
public void offer(E element) {
    if ((rear + 1) % elementData.length == front) throw new IllegalStateException("Queue full");
    elementData[rear] = element;
    rear = (rear + 1) % elementData.length;
}
```

##### 2.1.2.2. 出队

```java
public E poll() {
    if (isEmpty()) throw new IllegalStateException("Queue empty");
    E e = (E) elementData[front];
    front = (front + 1) % elementData.length;
    return e;
}
```

##### 2.1.2.3. 队空

```java
public boolean isEmpty() {
    return front == rear;
}
```

### 2.2. 链队

使用链表来实现。与单向链表数据结构类似。

![image-20221115014044212](https://fastly.jsdelivr.net/gh/xihuanxiaorang/images/202211150140260.png)

#### 2.2.1. 入队

```java
public void offer(E element) {
    Node<E> node = new Node<>(element, null);
    if (isEmpty()) {
        front = rear = node;
    } else {
        rear.next = node;
        rear = node;
    }
    size++;
}
```

#### 2.2.2. 出队

```java
public E poll() {
    if (isEmpty()) return null;
    E element = front.item;
    front = front.next;
    size--;
    return element;
}
```

#### 2.2.3. 队空

```java
public boolean isEmpty() {
    return front == null;
}
```

